sql injection
command injection
xss
broken access control
jackson bond, log4shell, ajp (vulnerabilities of outdated components)


auto encoders
stable diffusion

kubernetes, docker

DBMS, CN

Graphs



NTL(Extract, Transform, Load) and NIFI(Tool for automating data flow and processing)
















Imagine you’re managing a busy cafe where every order is logged. You have a 
record—a list of dish names ordered throughout the day—and you want to determine
which dishes are the most popular. Given an list of strings representing the dish
names and an integer P, your task is to return the P most frequently ordered dishes.

The results must be sorted by the number of orders, from the most frequent to 
the least. If two dishes have been ordered the same number of times, they should be listed in alphabetical order.

Input Format:
-------------
Line-1: comma separated line of words, list of words.
Line-2: An integer P, number of words to display. 

Output Format:
--------------
Print P number of most common used words.

Example 1:
----------
Input=
coffee,sandwich,coffee,tea,sandwich,muffin
2
Output=
[coffee, sandwich]

Explanation: "coffee" and "sandwich" are the two most frequently ordered items. 
Although both appear frequently, "coffee" is placed before "sandwich" because 
it comes earlier alphabetically.

Example 2:
----------
Input=
bagel,muffin,scone,bagel,bagel,scone,scone,muffin,muffin
3
Output=
[bagel, muffin, scone] 

Explanation: "bagel", "muffin", and "scone" are the three most popular dishes 
with order frequencies of 3, 3, and 2 respectively. Since "bagel" and "muffin" 
have the same frequency, they are ordered alphabetically.

Constraints:

- 1 ≤ orders.length ≤ 500  
- 1 ≤ orders[i].length ≤ 10  
- Each orders[i] consists of lowercase English letters.  
- P is in the range [1, The number of unique dish names in orders].






Imagine you're managing a busy warehouse where every product is delivered in 
pairs to ensure proper stocking. However, due to a mix-up at the shipping dock, 
two unique product IDs ended up without their matching pair, while all other 
products arrived as complete pairs. Your task is to identify these two solitary 
product IDs.

You're given list of product IDs. In this list, every product ID appears exactly 
twice except for two IDs that appear only once. Return these two unique product 
\IDs in any order.

You must design an algorithm that runs in linear time and uses only constant 
extra space.


Example 1:
----------
Input: 
101 102 101 103 102 105  
Output: 
[103, 105] 
 
Explanation: The IDs 103 and 105 appear only once, while all other IDs appear 
twice. [105, 103] is also an acceptable answer.

Example 2:
-----------
Input: 121 136
Output: [121, 136] 









At university of Chicago a Computer Science programing faculty as a part of 
teaching passion, in order to make newly joined students more enthusiastic 
in learning the subject he is given a problem at the first day of semester.
The student who solved it first, will be awarded with a cash prize. In regard 
to this he asked the students to work on concept related to strings, he gave a 
task to read a word and find the count of all the turn of phrases of the word, 
and the phrases should be distinct.

Now it’s your time to create a method which satisfies the above program.
The turn of phrases of a word is obtained by deleting 
any number of characters (possibly zero) from the front of the word and
any number of characters (possibly zero) from the back of the word.

Input Format:
-------------
A single string, the word contains only lowercase alphabets [a-z].

Output Format:
--------------
Print an integer, number of distinct phrases possible.


Sample Input-1:
---------------
aabbaba

Sample Output-1:
----------------
21

Explanation:
-------------
The turn of phrases of the word, which are distinct as follows:
a, b, aa, bb, ab, ba, aab, abb, bab, bba, aba, aabb, abba, bbab, baba, 
aabba, abbab, bbaba, aabbab, abbaba, aabbaba


Sample Input-2:
---------------
kmithyd

Sample Output-2:
----------------
28




Day 32

/*
Implement a JavaScript ES6 module named AdvancedFactorialTool that calculates 
factorials of numbers provided by the user. The implementation should 
integrate the following ES6 features:

1. Implement your own ES6 class named CustomMap to mimic JavaScript's built-in Map.
2. Use the above-created CustomMap explicitly for caching factorial results to 
   avoid redundant calculations.
3. Provide a deepClone function to clone the cache object deeply, protecting the 
   internal state from accidental external modifications.
4. Implement a generator named factorialGenerator(n) which yields factorial 
   results sequentially from 1! to n!.

*/


class CustomMap {
  // write your code here
  
}


const AdvancedFactorialTool = {
  factorialMemoized(n) {
    // write your code here
    
    
  },

  deepClone(obj) {
    // write your code here
    
    
  },

  *factorialGenerator(n) {
    // write your code here
    
  }
};









//Testing code
function testFactorialTool(n) {
  console.log(`Factorial of ${n} (Memoized):`, AdvancedFactorialTool.factorialMemoized(n));

  const originalCache = AdvancedFactorialTool.cache;
  const clonedCache = AdvancedFactorialTool.deepClone(originalCache);
  clonedCache.set(n, "modified");
  console.log("Original cache after clone modification:", originalCache.get(n));

  console.log(`Factorial sequence up to ${n}:`, [...AdvancedFactorialTool.factorialGenerator(n)]);
}

const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

readline.question('Enter a positive integer to calculate factorial: ', input => {
  const n = parseInt(input.trim());

  if (isNaN(n) || n <= 0) {
    console.log('Please enter a valid positive integer.');
  } else {
    testFactorialTool(n);
  }

  readline.close();
});






